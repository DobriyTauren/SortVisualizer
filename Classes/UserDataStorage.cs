using Blazored.LocalStorage;

namespace SortVisualizer.Client.Classes
{
    public class UserDataStorage
    {
        private int _itemsCount = 50;

        public int ItemsCount
        {
            get => _itemsCount;
            set
            {
                switch (value)
                {
                    case < 1:
                        _itemsCount = 1;
                        break;
                    case > 355:
                        _itemsCount = 355;
                        break;
                    default:
                        _itemsCount = value;
                        break;
                }
            }
        }

        public AlgorithmModel CurrentAlgorithm { get; set; }
        public List<AlgorithmModel> Algorithms { get; private set; } = new List<AlgorithmModel> 
        {
            new AlgorithmModel { Id = 0, Name = "Пузырьковая сортировка", Description = "Сортировка пузырьком – это простой алгоритм сортировки, который многократно проходит по списку, сравнивая соседние элементы и меняя их местами, если они стоят в неправильном порядке. Этот процесс продолжается до тех пор, пока весь список не будет отсортирован.\r\n\r\nОсновная идея сортировки пузырьком заключается в том, что за каждый проход по списку самый большой элемент \"всплывает\" к концу, как пузырёк в воде.\r\nЭтапы работы алгоритма:\r\n1. Проход по списку от начала до конца;\r\n2. Сравнение каждой пары соседних элементов;\r\n3. Обмен местами элементов, если первый больше второго;\r\n4. Повторение шагов 1-3, пока список не станет упорядоченным.\r\n\r\nВременные характеристики:\r\n1. Лучшее время (O(n)): Когда список уже отсортирован. Алгоритм пройдёт по списку один раз, не делая никаких перестановок;\r\n2. Среднее время (O(n²)): В большинстве случаев, когда элементы списка находятся в случайном порядке;\r\n3. Худшее время (O(n²)): Когда список отсортирован в обратном порядке. Алгоритм должен сделать наибольшее количество перестановок.\r\n\r\nСортировка пузырьком проста для понимания и реализации, но она неэффективна для больших списков из-за своего квадратичного времени выполнения в среднем и в худшем случаях.", CodeName = "bubble" },
            new AlgorithmModel { Id = 1, Name = "Сортировка вставками", Description = "Сортировка вставками – это метод сортировки, в котором каждый новый элемент \"вставляется\" в уже отсортированную часть списка на своё место. Поэтому алгоритм итеративно просматривает элементы списка, перемещая каждый элемент влево до тех пор, пока не найдёт своё правильное положение.\r\nКак это работает:\r\n1. Начиная со второго элемента списка, каждый элемент сравнивается с элементами, находящимися перед ним;\r\n2. Если элемент меньше предыдущего, они меняются местами, и этот процесс повторяется до тех пор, пока элемент не окажется на своём месте в отсортированной части списка.\r\n\r\nВременные характеристики:\r\n1. Лучшее время (O(n)): Когда список уже отсортирован. В этом случае не требуется никаких перестановок, и алгоритм пройдёт по списку всего один раз;\r\n2. Среднее время (O(n²)): В большинстве случаев, когда элементы списка находятся в случайном порядке;\r\n3. Худшее время (O(n²)): Когда список отсортирован в обратном порядке или в обратном порядке почти полностью. В таких случаях требуется максимальное количество перемещений.\r\n\r\nСортировка вставками эффективна для небольших списков и имеет преимущество в эффективности по сравнению с сортировкой пузырьком и сортировкой выбором. Однако для больших списков она может оказаться менее эффективной из-за своего квадратичного времени выполнения в среднем и в худшем случаях.", CodeName = "insert" },
            new AlgorithmModel { Id = 2, Name = "Быстрая сортировка", Description = "Быстрая сортировка - это эффективный алгоритм сортировки, который использует стратегию \"разделяй и властвуй\" для упорядочивания элементов списка. Он разбивает список на меньшие подсписки, сортирует каждый из них и объединяет весь список в один отсортированный результат.\r\nКак это работает:\r\n1. Выбор опорного элемента: Из списка выбирается опорный элемент, обычно это средний элемент. Остальные элементы списка разделяются на две подгруппы: элементы меньше опорного и элементы больше опорного;\r\n2. Рекурсивная сортировка подсписков: Каждая из подгрупп снова подвергается быстрой сортировке. Этот шаг повторяется, пока подсписки не станут достаточно маленькими для сортировки одним из базовых методов (например, сортировкой вставками);\r\n3. Объединение подсписков: После того как все подсписки отсортированы, они объединяются вместе, образуя окончательно отсортированный список.\r\n\r\nВременные характеристики: \r\n1. Лучшее время (O(n log n)): Когда опорный элемент разбивает список пополам на каждом шаге, что приводит к логарифмическому количеству шагов;\r\n2. Среднее время (O(n log n)): В большинстве случаев, когда элементы списка равномерно распределены;\r\n3. Худшее время (O(n²)): Когда список отсортирован в обратном порядке или в обратном порядке почти полностью.\r\n\r\nБыстрая сортировка обычно предпочтительнее для сортировки больших списков из-за её высокой эффективности в среднем случае, но она может потребовать дополнительной памяти для стека вызовов в рекурсивной реализации.", CodeName = "fast" },
            new AlgorithmModel { Id = 3, Name = "Сортировка перемешиванием", Description = "Сортировка перемешиванием, также известная как \"шейкерная сортировка\", это алгоритм сортировки, который чередует проходы в двух направлениях: сначала слева направо, затем справа налево. Он находит максимальный и минимальный элементы на каждом проходе и перемещает их на соответствующие концы списка.\r\nКак это работает:\r\n1. Проход слева направо: Алгоритм начинает с начала списка и сравнивает соседние элементы. Если текущий элемент больше следующего, они меняются местами;\r\n2. Проход справа налево: После того как первый проход завершён, алгоритм повторяет процесс, начиная с конца списка и двигаясь к началу;\r\n3. Повторение проходов: Этот процесс продолжается до тех пор, пока не будет выполнено ни одно обменное действие за проход.\r\n\r\nВременные характеристики:\r\n1. Лучшее время (O(n)): Когда список уже отсортирован. Алгоритм завершит работу за один проход без каких-либо обменов;\r\n2. Среднее время (O(n²)): В большинстве случаев, когда элементы списка находятся в случайном порядке;\r\n3. Худшее время (O(n²)): Когда список отсортирован в обратном порядке. В таком случае требуется максимальное количество проходов и обменов.\r\n\r\nСортировка перемешиванием привлекательна своей простотой и эффективностью на небольших списках. Однако для больших списков её производительность обычно не так хороша из-за квадратичного времени выполнения в среднем и в худшем случаях.", CodeName = "shaker" },
            new AlgorithmModel { Id = 4, Name = "Сортировка слиянием", Description = "Сортировка слиянием - это алгоритм сортировки, который использует метод \"разделяй и властвуй\" для упорядочивания элементов списка. Он разбивает список на две половины, рекурсивно сортирует каждую половину, а затем объединяет их в отсортированный список.\r\nКак это работает:\r\n1. Разделение списка: Исходный список делится пополам до тех пор, пока каждый подсписок не будет содержать только один элемент. Этот шаг создает базу для рекурсивного слияния;\r\n2. Рекурсивная сортировка: Каждая половина списка рекурсивно сортируется с помощью сортировки слиянием. Этот процесс продолжается, пока не останется только один элемент в каждом подсписке;\r\n3. Слияние подсписков: Отсортированные подсписки объединяются в один отсортированный список. Это делается путем сравнения элементов из каждого подсписка и последовательного добавления их в результирующий список.\r\n\r\nВременные характеристики:\r\n1. Лучшее время (O(n log n)): Всегда, даже когда список частично отсортирован или полностью отсортирован;\r\n2. Среднее время (O(n log n)): Это обычно случается в среднем случае, когда элементы списка равномерно распределены;\r\n3. Худшее время (O(n log n)): Как и среднее время, но это происходит в самом худшем случае.\r\n\r\nСортировка слиянием хорошо подходит для сортировки больших списков, так как её время выполнения остается стабильным, независимо от структуры или размера списка. Кроме того, этот алгоритм легко параллелизуем, что позволяет ускорить процесс сортировки на многопроцессорных системах.", CodeName = "merge" },
            new AlgorithmModel { Id = 5, Name = "Сортировка кучей", Description = "Сортировка кучей, также известная как heapsort, это алгоритм сортировки, который использует структуру данных \"куча\" для упорядочивания элементов в массиве или списке.\r\nКак это работает:\r\n1. Построение кучи: Начинается с построения кучи из заданного массива элементов. Это делается путем преобразования массива в бинарное дерево (кучу), где каждый узел больше (или меньше) своих дочерних узлов;\r\n2. Преобразование кучи в отсортированный список: Каждый раз, когда из кучи удаляется корневой элемент (максимальный или минимальный, в зависимости от порядка сортировки), он помещается в соответствующий конец сортируемого списка. После удаления корневого элемента куча перестраивается, чтобы восстановить свойство кучи;\r\n3. Повторение этого процесса: Этот процесс повторяется до тех пор, пока вся куча не будет пуста.\r\n\r\nВременные характеристики:\r\n1. Лучшее время (O(n log n)): Всегда, даже когда массив частично отсортирован или полностью отсортирован;\r\n2. Среднее время (O(n log n)): Это обычно случается в среднем случае, когда элементы списка равномерно распределены;\r\n3. Худшее время (O(n log n)): Всегда, когда элементы списка расположены в обратном порядке или близко к обратному порядку.\r\n\r\nСортировка кучей отличается от других алгоритмов тем, что не требует дополнительной памяти, поскольку весь процесс сортировки происходит на месте. Этот алгоритм также эффективен на практике, и его использование оправдано для больших массивов данных.", CodeName = "heap" },
            new AlgorithmModel { Id = 6, Name = "Сортировка Шелла", Description = "Сортировка Шелла - это алгоритм сортировки, который является улучшением сортировки вставками. Он основан на идее сравнения и перемещения элементов на некотором расстоянии друг от друга, что позволяет \"проскакивать\" элементы, расположенные далеко друг от друга, и быстрее перемещаться к своим финальным позициям.\r\n\r\nКак это работает:\r\n1. Выбор интервала сравнения: Алгоритм начинает с выбора большого интервала, который постепенно уменьшается с каждым проходом;\r\n2. Сортировка сравнением с шагом: Элементы массива сравниваются на заданном расстоянии (шаге). Если элементы находятся в неправильном порядке, они меняются местами;\r\n3. Уменьшение шага и повторение процесса: Шаг уменьшается, и процесс повторяется. Когда шаг становится равным единице, происходит окончательная сортировка методом вставок.\r\n\r\nВременные характеристики:\r\n1. Лучшее время (O(n log n)): В зависимости от выбора интервала сравнения, но обычно лучшее время близко к O(n log n);\r\n2. Среднее время (O(n log² n)): Среднее время сложности зависит от выбора интервалов сравнения и может быть существенно улучшено оптимальным выбором;\r\n3. Худшее время (O(n²)):  Худшее время также зависит от выбора интервалов сравнения, но обычно остается в пределах O(n²).\r\n\r\nСортировка Шелла предлагает значительное улучшение скорости сортировки по сравнению с сортировкой вставками за счет предварительной сортировки элементов на больших расстояниях друг от друга. Она часто используется в ситуациях, где требуется эффективная сортировка на практике, но нет необходимости в абсолютно оптимальном времени выполнения.", CodeName = "shell" },

        };
        
        public List<HistoryModel>? SmallHistory { get; private set; } = new List<HistoryModel>();
        public List<HistoryModel> FullHistory { get; private set; } = new List<HistoryModel>();
        public List<HistoryModel> FilteredHistory { get; private set; } = new List<HistoryModel>();
        public List<HistoryModel> SelectedHistory { get; private set; } = new List<HistoryModel>();

        public event EventHandler AlgorithmsChanged;
        public event EventHandler HistoryChanged;
        public event EventHandler FilteredHistoryChanged;

        public void AddToSelected (HistoryModel history)
        {
            SelectedHistory.Add(history);

            OnHistoryChanged();
        }

        public void ClearSelected()
        {
            SelectedHistory.Clear();

            OnHistoryChanged();
        }

        public void DeleteSelectedRecord (HistoryModel history)
        {
            SelectedHistory.Remove(history);

            OnHistoryChanged();
        }

        public async Task DeleteAllRecords(ILocalStorageService localStorage, IndexedDB indexedDB)
        {
            FullHistory.Clear();
            FilteredHistory.Clear();
            SelectedHistory.Clear();

            await indexedDB.DeleteAllObjects(localStorage);

            OnFilteredHistoryChanged();
        }

        public async Task DeleteSelectedRecords (ILocalStorageService localStorage, IndexedDB indexedDB)
        {
            // Create a hash set for SelectedHistory for faster lookups
            var selectedHashSet = new HashSet<HistoryModel>(SelectedHistory);

            FullHistory.RemoveAll(item => selectedHashSet.Contains(item));
            FilteredHistory.RemoveAll(item => selectedHashSet.Contains(item));

            await indexedDB.DeleteObjects(SelectedHistory, localStorage);

            SelectedHistory.Clear();
            OnFilteredHistoryChanged();
        }

        public void SetAlgorithms (List<AlgorithmModel> algorithms)
        {
            Algorithms = algorithms;

            OnAlgorithmsChanged();
        }

        public void SetSmallHistory (List<HistoryModel> history)
        {
            SmallHistory = history.TakeLast(10).Reverse().ToList();

            OnHistoryChanged();
        }
        
        public void SetFullHistory (List<HistoryModel> history)
        {
            FullHistory = history;

            OnHistoryChanged();
        }

        public void SetFilteredHistory(List<HistoryModel> history)
        {
            FilteredHistory = history;

            OnFilteredHistoryChanged();
        }

        public async Task AddHistory (HistoryModel history, ILocalStorageService localStorage, IndexedDB indexedDB)
        {
            try
            {
                await indexedDB.SaveObject(history, localStorage);
                
                if (SmallHistory.Count == 10)
                {
                    SmallHistory.Insert(0, history);

                    SmallHistory.Remove(SmallHistory.Last());
                }
                else
                {
                    SmallHistory.Insert(0, history);
                }
            }
            catch
            {
                Console.WriteLine($"[indexedDB] - error when adding record at " + DateTime.Now.ToLongTimeString());
            }

            OnHistoryChanged();
        }

        private void OnAlgorithmsChanged () 
        {
            AlgorithmsChanged?.Invoke(null, EventArgs.Empty);
        }
        
        private void OnHistoryChanged () 
        {
            HistoryChanged?.Invoke(null, EventArgs.Empty);
        }

        private void OnFilteredHistoryChanged()
        {
            FilteredHistoryChanged?.Invoke(null, EventArgs.Empty);
        }
    }
}
